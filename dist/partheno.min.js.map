{"version":3,"file":"partheno.min.js","mappings":"qBAMAA,EAAOC,QANP,SAAyBC,EAAUC,GACjC,KAAMD,aAAoBC,GACxB,MAAM,IAAIC,UAAU,oCAExB,C,UCJA,SAASC,EAAkBC,EAAQC,GACjC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CACrC,IAAIE,EAAaH,EAAMC,GACvBE,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjDC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,EAChD,CACF,CAQAV,EAAOC,QANP,SAAsBE,EAAac,EAAYC,GAG7C,OAFID,GAAYZ,EAAkBF,EAAYgB,UAAWF,GACrDC,GAAab,EAAkBF,EAAae,GACzCf,CACT,C,GCbIiB,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAatB,QAGrB,IAAID,EAASoB,EAAyBE,GAAY,CAGjDrB,QAAS,CAAC,GAOX,OAHAwB,EAAoBH,GAAUtB,EAAQA,EAAOC,QAASoB,GAG/CrB,EAAOC,OACf,CCrBAoB,EAAoBK,EAAI,CAACzB,EAAS0B,KACjC,IAAI,IAAIX,KAAOW,EACXN,EAAoBO,EAAED,EAAYX,KAASK,EAAoBO,EAAE3B,EAASe,IAC5EF,OAAOC,eAAed,EAASe,EAAK,CAAEL,YAAY,EAAMkB,IAAKF,EAAWX,IAE1E,ECNDK,EAAoBO,EAAI,CAACE,EAAKC,IAAUjB,OAAOK,UAAUa,eAAeC,KAAKH,EAAKC,G,iCCIlFG,yBAAyBf,UAAUgB,UAAY,SAASC,EAAGC,EAAGC,EAAGC,EAAGC,GAUhE,OATIF,EAAI,EAAIE,IAAGA,EAAIF,EAAI,GACnBC,EAAI,EAAIC,IAAGA,EAAID,EAAI,GACvBE,KAAKC,YACLD,KAAKE,OAAOP,EAAII,EAAGH,GACnBI,KAAKG,MAAMR,EAAIE,EAAGD,EAAGD,EAAIE,EAAGD,EAAIE,EAAGC,GACnCC,KAAKG,MAAMR,EAAIE,EAAGD,EAAIE,EAAGH,EAAGC,EAAIE,EAAGC,GACnCC,KAAKG,MAAMR,EAAGC,EAAIE,EAAGH,EAAGC,EAAGG,GAC3BC,KAAKG,MAAMR,EAAGC,EAAGD,EAAIE,EAAGD,EAAGG,GAC3BC,KAAKI,YACEJ,IACX,C","sources":["webpack://partheno/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://partheno/./node_modules/@babel/runtime/helpers/createClass.js","webpack://partheno/webpack/bootstrap","webpack://partheno/webpack/runtime/define property getters","webpack://partheno/webpack/runtime/hasOwnProperty shorthand","webpack://partheno/./src/Bookmark.class.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const STROKE_COLOR = '#FF0000';\nconst LINE_WIDTH = 1;\nconst TIMEOUT = 100;\n\nCanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    this.beginPath();\n    this.moveTo(x + r, y);\n    this.arcTo(x + w, y, x + w, y + h, r);\n    this.arcTo(x + w, y + h, x, y + h, r);\n    this.arcTo(x, y + h, x, y, r);\n    this.arcTo(x, y, x + w, y, r);\n    this.closePath();\n    return this;\n}\n\n// Initialization of a bookmark.\nexport default class BookMark {\n\n    /**\n     * Constructor.\n     * @param {number} _uniqueId\n     * @returns {BookMark}\n     */\n    constructor(build) {\n\n        this.uniqueId = build.uniqueId;\n        this.patterns = build.patterns;\n        this.height = build.height;\n        this.width = build.width;\n        this.chamfer = build.chamferWidth;\n        this.chamferRt = build.chamferRt;\n        this.chamferRb = build.chamferRb;\n        this.chamferLt = build.chamferLt;\n        this.chamferLb = build.chamferLb;\n        this.roundBorder = build.roundBorderWidth;\n        this.roundBorderRt = build.roundBorderRt;\n        this.roundBorderRb = build.roundBorderRb;\n        this.roundBorderLt = build.roundBorderLt;\n        this.roundBorderLb = build.roundBorderLb;\n        this.enableTriangles = build.enableTriangles;\n        this.numberOfPairOfTriangles = build.numberOfpairs;\n        this.showStrokes = build.showStrokes;\n        this.columnsPerWidth = build.columnsPerWidth;\n        this.canDownload = build.canDownload;\n        this.backgroundPattern = build.background;\n\n        if (!build.evenPattern) {\n            this.triangleEvenPattern = this._getRandomPattern('triangles');\n        } else {\n            this.triangleEvenPattern = build.evenPattern;\n        }\n\n        if (!build.oddPattern) {\n            this.triangleOddPattern = this._getRandomPattern('triangles');\n        } else {\n            this.triangleOddPattern = build.oddPattern;\n        }\n\n        this.images = [];\n        this.wrapper = null;\n\n        this._init();\n    }\n\n    static get Builder() {\n        class Builder {\n            /**\n             * @param {number} uniqueId \n             */\n            constructor(uniqueId) {\n                    this.uniqueId = uniqueId;\n                }\n                /**\n                 * @param {number} height \n                 * @param {number} width \n                 */\n            sized(height, width) {\n                    this.height = height;\n                    this.width = width;\n                    return this;\n                }\n                /**\n                 * @param {number} columnsPerWidth \n                 */\n            columnsPerWidth(columnsPerWidth) {\n                    this.columnsPerWidth = columnsPerWidth;\n                    return this;\n                }\n                /**\n                 * @param {boolean} canDownload \n                 */\n            downloadable(canDownload) {\n                    this.canDownload = canDownload;\n                    return this;\n                }\n                /**\n                 * @param {boolean} canDownload \n                 */\n            withStrokes(showStrokes) {\n                    this.showStrokes = showStrokes;\n                    return this;\n                }\n                /**\n                 * @param {string} background \n                 */\n            withBackground(background) {\n                    this.background = background;\n                    return this;\n                }\n                /**\n                 * @param {number} numberOfpairs \n                 */\n            withNumberOfPairs(numberOfpairs) {\n                    this.numberOfpairs = numberOfpairs;\n                    return this;\n                }\n                /**\n                 * @param {number} numberOfpairs \n                 */\n            withTriangles(enableTriangles) {\n                    this.enableTriangles = enableTriangles;\n                    return this;\n                }\n                /**\n                 * @param {Object} patterns \n                 * @param {string} evenPattern \n                 * @param {string} oddPattern \n                 */\n            withPatterns(patterns, evenPattern, oddPattern) {\n                    this.patterns = patterns;\n                    this.evenPattern = evenPattern;\n                    this.oddPattern = oddPattern;\n                    return this;\n                }\n                /**\n                 * @param {number} chamferWidth \n                 * @param {boolean} chamferRt \n                 * @param {boolean} chamferRb \n                 * @param {boolean} chamferLt \n                 * @param {boolean} chamferLb \n                 */\n            withChamfers(chamferWidth, chamferRt, chamferRb, chamferLt, chamferLb) {\n                    this.chamferWidth = chamferWidth;\n                    this.chamferRt = chamferRt;\n                    this.chamferRb = chamferRb;\n                    this.chamferLt = chamferLt;\n                    this.chamferLb = chamferLb;\n                    return this;\n                }\n                /**\n                 * @param {number} roundBorderWidth \n                 * @param {boolean} roundBorderRt \n                 * @param {boolean} roundBorderRb \n                 * @param {boolean} roundBorderLt \n                 * @param {boolean} roundBorderLb \n                 */\n            withRoundBorder(roundBorderWidth, roundBorderRt, roundBorderRb, roundBorderLt, roundBorderLb) {\n                this.roundBorderWidth = roundBorderWidth;\n                this.roundBorderRt = roundBorderRt;\n                this.roundBorderRb = roundBorderRb;\n                this.roundBorderLt = roundBorderLt;\n                this.roundBorderLb = roundBorderLb;\n                return this;\n            }\n\n            build() {\n                return new BookMark(this);\n            }\n        }\n        return Builder;\n    }\n\n    /**\n     * First init canvas and ctx.\n     * @private\n     */\n    _init() {\n        this._createCanvasWrapper('canva-' + this.uniqueId, 'zone-' + this.uniqueId);\n        this.zone = 'background';\n        this._initPatterns();\n        this.zone = 'triangles';\n        this._initPatterns();\n    }\n\n    /**\n     * Randomly returns a pattern.\n     * @param {string} zone\n     * @returns {string|null}\n     * @private\n     */\n    _getRandomPattern(zone) {\n        let result, value;\n        if (typeof this.patterns[zone] !== 'undefined') {\n            value = Math.floor(Math.random() * this.patterns[zone].length);\n            result = this._getFullDecodedPath(this.patterns[zone][value].data);\n        }\n        return result;\n    }\n\n    /**\n     * Return true if at least one chamfer is enabled.\n     * @returns {boolean}\n     * @private\n     */\n    _hasChamfer() {\n        return (this.chamferRt || this.chamferRb || this.chamferLt || this.chamferLb);\n    }\n\n    /**\n     * Return true if at least one round border is enabled.\n     * @returns {boolean}\n     * @private\n     */\n    _hasRoundBorder() {\n        return (this._roundBorderRt || this._roundBorderRb || this._roundBorderLt || this._roundBorderLb);\n    }\n\n    /**\n     * Return clean full path of a pattern.\n     * @param {string} path\n     * @returns {string}\n     * @private\n     */\n    _getFullDecodedPath(path) {\n        return Buffer.from(this.patterns.path + path, 'binary').toString('base64');\n    }\n\n    /**\n     * Encode a string.\n     * @param {string} stringPattern \n     */\n    _encode(stringPattern) {\n        return Buffer.from(stringPattern, 'base64').toString('binary');\n    }\n\n    /**\n     * Find a pattern in a list of patterns.\n     * @param {string} searchedPattern\n     * @return {string}\n     * @private\n     */\n    _findPattern(searchedPattern) {\n        let pattern;\n        this.patterns.background.map((elem) => {\n            if (elem.data === searchedPattern) {\n                pattern = elem.data;\n            }\n        });\n        return pattern;\n    }\n\n    /**\n     * Initialize the background.\n     * @param {string|Array} backgroundPattern\n     * @private\n     */\n    _setBackgroundPatterns(backgroundPattern) {\n\n        if (this._hasRoundBorder()) {\n\n            this._drawRoundedRect(\n                0,\n                0,\n                this.width,\n                this.height,\n                this.roundBorder,\n                this.roundBorderRt,\n                this.roundBorderRb,\n                this.roundBorderLt,\n                this.roundBorderLb\n            );\n        }\n\n        if (this._hasChamfer()) {\n            this._drawChamferedRect(\n                0,\n                0,\n                this.width,\n                this.height,\n                this.chamfer,\n                this.chamferRt,\n                this.chamferRb,\n                this.chamferLt,\n                this.chamferLb\n            );\n\n        }\n\n        // Patterns could be stored in an array or in a single string because of mirrored patterns.\n        if (Array.isArray(backgroundPattern)) {\n            this._buidMirroredPattern(backgroundPattern);\n            this.elCtx.fill();\n        } else {\n            this._applyStyle(this.images[this._getFullDecodedPath(backgroundPattern)]);\n            this.elCtx.fillRect(0, 0, this.width, this.height);\n        }\n    }\n\n    /**\n     * Build a mirrored background pattern.\n     * @param {Object} patterns\n     * @private\n     */\n    _buidMirroredPattern(patterns) {\n        // Black background\n        this.elCtx.strokeRect(0, 0, this.width, this.height);\n\n        let pow = parseFloat(this.width / 2);\n        let width = this.width;\n        let height = this.height;\n\n        patterns.forEach((pattern, index) => {\n            let currentImage = this.images[this._getFullDecodedPath(pattern)];\n            if (currentImage) {\n                // Top left.\n                if (index === 0) {\n                    this.elCtx.drawImage(currentImage, 0, 0, width, height);\n                }\n                // Top right.\n                if (index === 1) {\n                    this.elCtx.drawImage(currentImage, pow, 0, width, height);\n                }\n                // Bottom left.\n                if (index === 2) {\n                    this.elCtx.drawImage(currentImage, 0, 200, width, height);\n                }\n                // Bottom right.\n                if (index === 3) {\n                    this.elCtx.drawImage(currentImage, pow, 200, width, height);\n                }\n            }\n        });\n    }\n\n    /**\n     * Build a chamfered background pattern.\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     * @param {number} radius\n     * @param {boolean} rt\n     * @param {boolean} lt\n     * @param {boolean} rb\n     * @param {boolean} lb\n     * @private\n     */\n    _drawChamferedRect(x, y, w, h, radius, rt, lt, rb, lb) {\n        let r = x + w;\n        let b = y + h;\n        this.elCtx.moveTo(x + radius, y);\n        if (rt) {\n            this.elCtx.lineTo(r - radius, y);\n            this.elCtx.lineTo(r, y + radius);\n        } else {\n            this.elCtx.lineTo(r - radius, y);\n            this.elCtx.lineTo(r, y);\n        }\n\n        if (lb) {\n            this.elCtx.lineTo(r, y + h - radius);\n            this.elCtx.lineTo(r - radius, b);\n        } else {\n            this.elCtx.lineTo(r, y + h);\n        }\n\n        if (lt) {\n            this.elCtx.lineTo(x + radius, b);\n            this.elCtx.lineTo(x, b - radius);\n        } else {\n            this.elCtx.lineTo(x, b);\n        }\n\n        if (rb) {\n            this.elCtx.lineTo(x, y + radius);\n            this.elCtx.lineTo(x + radius, y);\n        } else {\n            this.elCtx.lineTo(x, y);\n        }\n    }\n\n    /**\n     * Draw a canvas.\n     * @param {string} elementId\n     * @param {string} zoneId\n     * @private\n     */\n    _createCanvasWrapper(elementId, zoneId) {\n\n        let _zone = document.createElement('div');\n        _zone.id = zoneId;\n        _zone.className = 'zone';\n\n        let _canvas = document.createElement('canvas');\n        _canvas.id = elementId;\n        _canvas.className = 'zone--canvas';\n        _canvas.width = this.width;\n        _canvas.height = this.height;\n        _canvas.showStrokes = this.showStrokes;\n\n        _canvas.chamfer = this.chamfer;\n        _canvas.chamferRt = this.chamferRt;\n        _canvas.chamferRb = this.chamferRb;\n        _canvas.chamferLt = this.chamferLt;\n        _canvas.chamferLb = this.chamferLb;\n\n        _canvas.roundBorder = this._roundBorder;\n        _canvas.roundBorderRt = this.roundBorderRt;\n        _canvas.roundBorderRb = this.roundBorderRb;\n        _canvas.roundBorderLt = this.roundBorderLt;\n        _canvas.roundBorderLb = this.roundBorderLb;\n\n        _canvas.backgroundPatternTriangleEven = this.triangleEvenPattern;\n        _canvas.backgroundPatternTriangleOdd = this.triangleOddPattern;\n        _canvas.innerHTML = 'Votre navigateur ne supporte pas canvas.<br>Essayez avec Firefox, Safari, Chrome ou Opera.';\n\n        setTimeout(() => {\n            this.clearCanvasLayers();\n            if (_zone) {\n                _zone.appendChild(_canvas);\n            }\n        }, TIMEOUT);\n\n        this.wrapper = _zone;\n        this.el_canvas = _canvas;\n        this.elCtx = this.el_canvas.getContext('2d');\n\n        setTimeout(() => {\n            // Show download link if can download picture is set to true.\n            if (this._canDownload()) {\n                this._createDownloadLink('link-' + this.uniqueId, 'zone-' + this.uniqueId);\n            }\n        });\n\n    }\n\n    /**\n     * Erase a canvas.\n     */\n    clearCanvasLayers() {\n        if (this.el_canvas) {\n            let w = this.el_canvas.clientWidth;\n            let h = this.el_canvas.clientHeight;\n            this.elCtx.clearRect(0, 0, w, h);\n        }\n    }\n\n    /**\n     * Get filtered patterns.\n     * @returns {Array}\n     */\n    getFiltered() {\n        let filteredFull = [];\n        for (let i = 0; i < this.patterns[this.zone].length; i++) {\n            let pattern = this.patterns[this.zone][i];\n            if (pattern.data) {\n                filteredFull.push(pattern.data);\n            }\n        }\n        return filteredFull;\n    }\n\n    /**\n     * Get filtered patterns object.\n     * @param {string} zone\n     * @returns {Array}\n     */\n    getFilteredPatternsObjects(zone) {\n        let filteredFull = {};\n\n        this.patterns[zone].filter((pattern) => {\n            if (pattern.data) {\n                filteredFull[pattern.title] = pattern.data;\n            }\n            return true;\n        });\n        return filteredFull;\n    }\n\n    /**\n     * Initialize the patterns, we decrement a variable. When it is zero we continue the loading script of the canvas.\n     * @private\n     */\n    _initPatterns() {\n        let filteredPatterns = this.getFiltered();\n\n        if (filteredPatterns && Array.isArray(filteredPatterns)) {\n            let _imagesLoading = filteredPatterns.length;\n\n            filteredPatterns.forEach((pattern) => {\n                if (Array.isArray(pattern)) {\n                    pattern.forEach((ss_pattern) => {\n                        let ss_image = new Image();\n                        let ss_elpattern = this._getFullDecodedPath(ss_pattern);\n                        ss_image.onload = () => {\n                            this.images[ss_elpattern] = ss_image;\n                            this.repeatBackgroundWidth = this.width / ss_image.width;\n                            this.repeatBackgroundHeight = this.height / ss_image.height;\n                        };\n                        ss_image.src = this._encode(ss_elpattern);\n\n                        if (_imagesLoading === 0) {\n                            this._triggeredOnPattersLoaded(this._encode(ss_elpattern));\n                        }\n                    });\n\n                    --_imagesLoading;\n                } else {\n                    let image = new Image();\n                    let elpattern = this._getFullDecodedPath(pattern);\n                    image.onload = () => {\n                        this.images[elpattern] = this.elCtx.createPattern(image, 'repeat');\n                        --_imagesLoading;\n                        if (_imagesLoading === 0) {\n                            this._triggeredOnPatternsLoaded(this._encode(elpattern));\n                        }\n                    };\n                    image.src = this._encode(elpattern);\n                }\n\n            });\n        }\n    }\n\n    /**\n     * Create a link to download an image of the canvas.\n     * @param {string} uniqueId \n     * @param {string} zoneId \n     * @param {string} classes \n     * @param {string} title \n     */\n    _createDownloadLink(uniqueId, zoneId, classes = 'btn btn-dark btn-sm', title = 'Download') {\n        let _zone = document.getElementById(zoneId);\n        let _link = document.createElement('a');\n\n        _link.innerHTML = title;\n        _link.classList = classes;\n        _link.id = uniqueId;\n        _link.href = '#';\n        _link.role = 'button';\n        _link.addEventListener('click', () => {\n            _link.href = this.el_canvas.toDataURL('image/jpeg');\n            _link.download = 'bookmark.jpg';\n        }, false);\n\n        if (_zone) {\n            _zone.insertBefore(_link, _zone.firstChild);\n        }\n    }\n\n    /**\n     * Draw Background.\n     * @private\n     */\n    _drawBackgroundPattern() {\n        this._setBackgroundPatterns(this.backgroundPattern);\n    }\n\n    /**\n     * Apply a pattern to a context of a canvas.\n     * @param {Object.<CanvasPattern>} style\n     * @private\n     */\n    _applyStyle(style) {\n        this.elCtx.fillStyle = style;\n    }\n\n    /**\n     * Draw a single even or odd triangle.\n     * @param {boolean} isEven\n     * @private\n     */\n    _drawSingleTriangle(isEven) {\n        let pattern;\n        this.patterns.triangles.map((b) => {\n            if (b.data === ((isEven === true) ? this.el_canvas.backgroundPatternTriangleEven : this.el_canvas.backgroundPatternTriangleOdd)) {\n                pattern = b.data;\n            }\n        });\n\n        this._applyStyle(this.images[this._getFullDecodedPath(pattern)]);\n\n        if (isEven) {\n            this.elCtx.lineTo(this._column_width + this._offset, this._first_coef);\n            this.elCtx.lineTo(this._offset, this._first_coef);\n        } else {\n            this.elCtx.lineTo(this._column_width + this._offset, this._second_coef);\n            this.elCtx.lineTo(this._offset, this._second_coef);\n        }\n    }\n\n    /**\n     * Draw the pairs of triangles.\n     * @private\n     */\n    _drawTriangles() {\n        if (this._hasChamfer()) {\n            this.elCtx.clip();\n        }\n\n        let _triangle_height;\n        this._column_width = this.width / this.columnsPerWidth;\n        let _half_width = this._column_width / 2;\n\n        // Draw each triangle pair.\n        for (let j = 1; j <= this.numberOfPairOfTriangles; j++) {\n\n            // Draw each column.\n            for (let l = 0; l < this.columnsPerWidth; l++) {\n\n                // Thickness of cut lines.\n                this.elCtx.lineWidth = LINE_WIDTH;\n\n                // The offset between each column.\n                this._offset = l * this._column_width;\n\n                _triangle_height = this.height / (this.numberOfPairOfTriangles * 2);\n\n                // Move these coef might glitch everything.\n                this._first_coef = 2 * (_triangle_height * j - _triangle_height);\n                this._second_coef = this._first_coef + (2 * _triangle_height);\n                this._third_coef = ((this._second_coef - _triangle_height) / j) * j;\n\n                // Draw a pair of triangles.\n                for (let k = 1; k <= 2; k++) {\n                    this.elCtx.beginPath();\n                    this.elCtx.moveTo(_half_width + this._offset, this._third_coef);\n\n                    // Draw a triangle with the base at the top or at the bottom.\n                    if (k % 2 === 1) {\n                        this._drawSingleTriangle(true);\n                    } else {\n                        this._drawSingleTriangle(false);\n                    }\n\n                    this.elCtx.closePath();\n                    this._drawStrokes();\n                    this.elCtx.fill();\n                }\n            }\n        }\n\n        if (this._hasChamfer()) {\n            this.elCtx.restore();\n        }\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    _canDownload() {\n        return this.canDownload === true;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    _canDrawTriangle() {\n        return this.enableTriangles === true;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    _canDisplayStrokes() {\n        return this.el_canvas.showStrokes === true;\n    }\n\n    /**\n     * Draw strokes or not.\n     * @private\n     */\n    _drawStrokes() {\n        // If show strokes flag is on.\n        if (this._canDisplayStrokes()) {\n            this.elCtx.strokeStyle = STROKE_COLOR;\n            this.elCtx.stroke();\n        }\n    }\n\n    /**\n     * Render the bookmark.\n     */\n    render() {\n        setTimeout(() => {\n            this._drawBackgroundPattern();\n            if (this._canDrawTriangle()) {\n                this._drawTriangles();\n            }\n        }, TIMEOUT);\n    }\n\n    /**\n     * Function called when all images are loaded.\n     * @param {string} loadedPattern\n     * @private\n     */\n    _triggeredOnPatternsLoaded(loadedPattern) {\n        this.clearCanvasLayers();\n        this.render();\n    }\n}"],"names":["module","exports","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","get","obj","prop","hasOwnProperty","call","CanvasRenderingContext2D","roundRect","x","y","w","h","r","this","beginPath","moveTo","arcTo","closePath"],"sourceRoot":""}